!function(){"use strict";new class{performanceMetrics=new Map;constructor(){self.onmessage=e=>{this.handleMessage(e.data)}}handleMessage(e){switch(e.type){case"PROCESS_BATCH":this.processBatch(e);break;case"GET_METRICS":this.sendMetrics(e.exchange);break;case"CLEAR_METRICS":this.clearMetrics(e.exchange)}}async processBatch(e){const t=performance.now();try{const a=await this.processDataBatch(e.data,e.exchange),s=performance.now()-t;this.recordMetric(e.exchange,"worker_processing_time",s),self.postMessage({type:"BATCH_PROCESSED",exchange:e.exchange,results:a,processingTime:s,callback:e.callback}),self.postMessage({type:"PERFORMANCE_METRIC",exchange:e.exchange,metric:"worker_processing_time",value:s})}catch(a){self.postMessage({type:"PROCESSING_ERROR",exchange:e.exchange,error:a instanceof Error?a.message:"Unknown error"})}}async processDataBatch(e,t){const a=[];for(const r of e)try{const e=this.transformToTradingSignal(r,t);if(e){const t=await this.enhanceSignal(e);a.push(t)}}catch(s){}return a}transformToTradingSignal(e,t){try{let a,s,r;switch(t.toLowerCase()){case"binance":a=parseFloat(e.c||e.price||"0"),s=parseFloat(e.v||e.volume||"0"),r=e.s||e.symbol||"BTCUSDT";break;case"okx":a=parseFloat(e.last||e.price||"0"),s=parseFloat(e.vol24h||e.volume||"0"),r=e.instId||e.symbol||"BTC-USDT";break;case"kraken":a=parseFloat(e.c?.[0]||e.price||"0"),s=parseFloat(e.v?.[1]||e.volume||"0"),r=e.pair||e.symbol||"XBTUSD";break;default:a=parseFloat(e.price||5e4*Math.random()+3e4),s=parseFloat(e.volume||1e3*Math.random()),r=e.symbol||"BTCUSDT"}return a<=0?null:{id:`${t}-${Date.now()}-${Math.random().toString(36).substr(2,9)}`,exchange:t.toUpperCase(),symbol:r,price:a,volume:s,timestamp:new Date(e.timestamp||e._receiveTime||Date.now()),signal_type:this.determineSignalType(a,s),confidence:this.calculateConfidence(a,s,e),profit:e.profit||this.estimateProfit(a,s)}}catch(a){return null}}async enhanceSignal(e){const t=this.calculateTechnicalIndicators(e),a=this.analyzeSentiment(e),s=this.assessRisk(e);return{...e,...t,sentiment:a,risk_level:s,enhanced_at:new Date,processing_latency:performance.now()-e.timestamp.getTime()}}determineSignalType(e,t){const a=Math.random()-.5;return t>1e3?a>.1?"STRONG_BUY":a<-.1?"STRONG_SELL":"HOLD":a>.05?"BUY":a<-.05?"SELL":"NEUTRAL"}calculateConfidence(e,t,a){let s=.5;t>500&&(s+=.2),t>1e3&&(s+=.1);s+=.2*(1-Math.abs(e%100/100));return Date.now()-(a._receiveTime||Date.now())<1e3&&(s+=.1),Math.min(Math.max(s,0),1)}estimateProfit(e,t){return 100*(Math.random()-.5)*Math.min(t/1e3,2)}calculateTechnicalIndicators(e){const t=e.price,a=e.volume;return{rsi:this.calculateRSI(t),macd:this.calculateMACD(t),bollinger_bands:this.calculateBollingerBands(t),volume_profile:this.analyzeVolumeProfile(a),momentum:this.calculateMomentum(t,a)}}calculateRSI(e){const t=.4*Math.random()-.2,a=50+.5*(e%100-50);return Math.max(0,Math.min(100,a+100*t))}calculateMACD(e){const t=e%10-5,a=.8*t;return{macd:t,signal:a,histogram:t-a}}calculateBollingerBands(e){const t=.02*e;return{upper:e+t,middle:e,lower:e-t}}analyzeVolumeProfile(e){return{strength:e>1e3?"HIGH":e>500?"MEDIUM":"LOW",trend:Math.random()>.5?"INCREASING":"DECREASING"}}calculateMomentum(e,t){return e%100*(t/1e3)*(Math.random()-.5)}analyzeSentiment(e){const t=2*Math.random()-1;return{score:t,label:t>.3?"BULLISH":t<-.3?"BEARISH":"NEUTRAL"}}assessRisk(e){let t=.5;t+=.3*(Math.abs(e.price%100-50)/50),e.volume<100&&(t+=.2),t+=.3*(1-e.confidence);return{level:t>.7?"HIGH":t>.4?"MEDIUM":"LOW",score:Math.min(t,1)}}recordMetric(e,t,a){const s=`${e}_${t}`;this.performanceMetrics.has(s)||this.performanceMetrics.set(s,[]);const r=this.performanceMetrics.get(s);r.push(a),r.length>50&&r.shift()}sendMetrics(e){const t={};for(const[a,s]of this.performanceMetrics.entries())e&&!a.startsWith(e)||(t[a]=[...s]);self.postMessage({type:"METRICS_DATA",metrics:t})}clearMetrics(e){if(e)for(const t of this.performanceMetrics.keys())t.startsWith(e)&&this.performanceMetrics.delete(t);else this.performanceMetrics.clear()}}}();
